import optuna
from sklearn.cluster import KMeans, DBSCAN, AgglomerativeClustering
from sklearn.metrics import silhouette_score
from sklearn.datasets import make_blobs
import numpy as np

# Function to perform clustering and optimize both algorithm and hyperparameters
def optimize_clustering(X, n_trials=100):
    """
    Optimizes clustering algorithm choice and hyperparameters using Optuna.
    
    Parameters:
    X: array-like, shape (n_samples, n_features) - Input dataset for clustering.
    n_trials: int - Number of optimization trials to run with Optuna.

    Returns:
    best_model: Trained clustering model with best algorithm and hyperparameters.
    best_params: The best algorithm and hyperparameters found by Optuna.
    """
    
    # Objective function for Optuna optimization
    def objective(trial):
        # Choose a clustering algorithm to optimize
        algorithm_choice = trial.suggest_categorical('algorithm', ['kmeans', 'dbscan', 'agglomerative'])
        
        if algorithm_choice == 'kmeans':
            # KMeans hyperparameters
            n_clusters = trial.suggest_int('n_clusters', 2, 20)
            init = trial.suggest_categorical('init', ['k-means++', 'random'])
            max_iter = trial.suggest_int('max_iter', 100, 500)
            algorithm_kmeans = trial.suggest_categorical('algorithm', ['auto', 'full', 'elkan'])

            model = KMeans(n_clusters=n_clusters, init=init, max_iter=max_iter, algorithm=algorithm_kmeans)
        
        elif algorithm_choice == 'dbscan':
            # DBSCAN hyperparameters
            eps = trial.suggest_float('eps', 0.1, 1.0)
            min_samples = trial.suggest_int('min_samples', 3, 10)

            model = DBSCAN(eps=eps, min_samples=min_samples)
        
        elif algorithm_choice == 'agglomerative':
            # AgglomerativeClustering hyperparameters
            n_clusters = trial.suggest_int('n_clusters', 2, 20)
            linkage = trial.suggest_categorical('linkage', ['ward', 'complete', 'average', 'single'])

            model = AgglomerativeClustering(n_clusters=n_clusters, linkage=linkage)
        
        # Fit the model and compute the silhouette score (objective to maximize)
        model.fit(X)
        if len(set(model.labels_)) > 1:  # Silhouette score requires at least 2 clusters
            score = silhouette_score(X, model.labels_)
        else:
            score = -1  # Penalize models with poor clustering (single cluster or undefined labels)
        
        return score
    
    # Create Optuna study and optimize for best algorithm and parameters
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=n_trials)

    # Get the best trial and retrieve the best model with parameters
    best_params = study.best_params
    algorithm_choice = best_params.pop('algorithm')  # Remove algorithm choice from best_params

    if algorithm_choice == 'kmeans':
        best_model = KMeans(**best_params)
    elif algorithm_choice == 'dbscan':
        best_model = DBSCAN(**best_params)
    elif algorithm_choice == 'agglomerative':
        best_model = AgglomerativeClustering(**best_params)

    best_model.fit(X)  # Fit the best model to the data
    return best_model, study.best_params

# Example usage with synthetic data
if __name__ == '__main__':
    # Create synthetic data (you can replace this with any dataset)
    X, _ = make_blobs(n_samples=100, centers=3, random_state=42)

    # Optimize clustering algorithm and hyperparameters
    best_model, best_params = optimize_clustering(X, n_trials=50)
    
    print("Best Clustering Algorithm and Hyperparameters:", best_params)
    print("Best Clustering Labels:", best_model.labels_)
